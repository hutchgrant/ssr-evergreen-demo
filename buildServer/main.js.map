{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"jsdom\"","webpack:///external \"puppeteer\"","webpack:///./ssr.js","webpack:///./renderer.js","webpack:///external \"url\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","MOBILE_USERAGENT","Renderer","constructor","browser","this","[object Object]","requestUrl","isMobile","page","newPage","setViewport","width","height","setUserAgent","evaluateOnNewDocument","response","addListener","goto","timeout","waitUntil","e","console","error","status","content","headers","statusCode","newStatusCode","$eval","element","parseInt","getAttribute","catch","undefined","result","evaluate","close","__webpack_exports__","jsdom__WEBPACK_IMPORTED_MODULE_0__","puppeteer__WEBPACK_IMPORTED_MODULE_1__","_ssr__WEBPACK_IMPORTED_MODULE_2__","_ref","clientStats","absPath","async","req","res","log","protocol","originalUrl","indexOf","puppeteer","headless","args","renderer","serialize","dom","JSDOM","send"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = require(\"jsdom\");","module.exports = require(\"puppeteer\");","/*\n* Rendertron - Modified\n* Repo: https://github.com/GoogleChrome/rendertron\n* License: MIT\n*/\n\n// \"use strict\";\n// Object.defineProperty(exports, '\"__esModule', { value: true });\nconst url = require('url');\nconst MOBILE_USERAGENT = 'Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.75 Mobile Safari/537.36';\n\n/**\n * Wraps Puppeteer's interface to Headless Chrome to expose high level rendering\n * APIs that are able to handle web components and PWAs.\n */\nclass Renderer {\n  constructor(browser) {\n    this.browser = browser;\n  }\n  async serialize(requestUrl, isMobile) {\n    /**\n     * Executed on the page after the page has loaded. Strips script and\n     * import tags to prevent further loading of resources.\n     */\n    function stripPage() {\n      // Strip only script tags that contain JavaScript (either no type attribute or one that contains \"javascript\")\n      const elements = document.querySelectorAll('script:not([type]), script[type*=\"javascript\"], link[rel=import]');\n\n      for (const e of Array.from(elements)) {\n        e.remove();\n      }\n    }\n    /**\n     * Injects a <base> tag which allows other resources to load. This\n     * has no effect on serialised output, but allows it to verify render\n     * quality.\n     */\n    function injectBaseHref(origin) {\n      const base = document.createElement('base');\n\n      base.setAttribute('href', origin);\n      const bases = document.head.querySelectorAll('base');\n\n      if (bases.length) {\n        // Patch existing <base> if it is relative.\n        const existingBase = bases[0].getAttribute('href') || '';\n\n        if (existingBase.startsWith('/')) {\n          bases[0].setAttribute('href', origin + existingBase);\n        }\n      } else {\n        // Only inject <base> if it doesn't already exist.\n        document.head.insertAdjacentElement('afterbegin', base);\n      }\n    }\n    const page = await this.browser.newPage();\n\n    // Page may reload when setting isMobile\n    // https://github.com/GoogleChrome/puppeteer/blob/v1.10.0/docs/api.md#pagesetviewportviewport\n    await page.setViewport({ width: 1000, height: 1000, isMobile });\n    if (isMobile) {\n      page.setUserAgent(MOBILE_USERAGENT);\n    }\n    page.evaluateOnNewDocument('customElements.forcePolyfill = true');\n    page.evaluateOnNewDocument('ShadyDOM = {force: true}');\n    page.evaluateOnNewDocument('ShadyCSS = {shimcssproperties: true}');\n    let response = null;\n\n    // Capture main frame response. This is used in the case that rendering\n    // times out, which results in puppeteer throwing an error. This allows us\n    // to return a partial response for what was able to be rendered in that\n    // time frame.\n    page.addListener('response', (r) => {\n      if (!response) {\n        response = r;\n      }\n    });\n    try {\n      // Navigate to page. Wait until there are no oustanding network requests.\n      response = await page.goto(requestUrl, { timeout: 10000, waitUntil: 'networkidle0' });\n    } catch (e) {\n      console.error(e);\n    }\n    if (!response) {\n      console.error('response does not exist');\n      // This should only occur when the page is about:blank. See\n      // https://github.com/GoogleChrome/puppeteer/blob/v1.5.0/docs/api.md#pagegotourl-options.\n      return { status: 400, content: '' };\n    }\n    // Disable access to compute metadata. See\n    // https://cloud.google.com/compute/docs/storing-retrieving-metadata.\n    if (response.headers()['metadata-flavor'] === 'Google') {\n      return { status: 403, content: '' };\n    }\n    // Set status to the initial server's response code. Check for a <meta\n    // name=\"render:status_code\" content=\"4xx\" /> tag which overrides the status\n    // code.\n    let statusCode = response.status();\n    const newStatusCode = await page\n      .$eval('meta[name=\"render:status_code\"]', (element) => parseInt(element.getAttribute('content'), 10) || '')\n      .catch(() => undefined);\n\n    // On a repeat visit to the same origin, browser cache is enabled, so we may\n    // encounter a 304 Not Modified. Instead we'll treat this as a 200 OK.\n    if (statusCode === 304) {\n      statusCode = 200;\n    }\n    // Original status codes which aren't 200 always return with that status\n    // code, regardless of meta tags.\n    if (statusCode === 200 && newStatusCode) {\n      statusCode = newStatusCode;\n    }\n    // Remove script & import tags.\n    // await page.evaluate(stripPage);\n    // Inject <base> tag with the origin of the request (ie. no path).\n    // const parsedUrl = url.parse(requestUrl);\n\n    // await page.evaluate(injectBaseHref, `${parsedUrl.protocol}//${parsedUrl.host}`);\n    // Serialize page.\n    const result = await page.evaluate('document.firstElementChild.outerHTML');\n\n    // console.log(result);\n    await page.close();\n\n    return { status: statusCode, content: result };\n  }\n}\nexports.Renderer = Renderer;","import { JSDOM } from 'jsdom';\nimport * as puppeteer from 'puppeteer';\nimport { Renderer } from './ssr';\n\nexport default ({ clientStats, absPath }) => async (req, res) => {\n\n  console.log(req.protocol + '://' + req.get('host') + req.originalUrl);\n\n  if (req.originalUrl.indexOf('.') === -1) {\n    const browser = await puppeteer.launch({\n      headless: true,\n      args: ['--no-sandbox']\n    });\n\n    const renderer = new Renderer(browser);\n    let result = await renderer.serialize(absPath, false);\n\n    // console.log(result.content);\n\n    const dom = new JSDOM(result.content);\n\n    /* Manipulate the dom from server */\n    // dom.window.document.head\n    //   .insertAdjacentHTML('beforeend', '<script src=\"https://cdnjs.cloudflare.com/ajax/libs/webcomponentsjs/2.0.2/webcomponents-bundle.js\"></script>');\n    // dom.window.document.body.insertAdjacentHTML('beforeend', js);\n\n    res.send(dom.serialize());\n  } else {\n    res.send('');\n  }\n\n};","module.exports = require(\"url\");"],"sourceRoot":""}